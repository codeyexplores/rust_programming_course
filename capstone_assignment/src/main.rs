/*
Scenario
You work as a Data Engineer for a Financial Services firm that manages corporate customer 
investments. You are given raw data (provided by trainer) representing transactions of of 
all assets under management. 

You are responsible for developing a Rust program to process this raw data so that it can 
be used stored in an analytics database and used productively by the Data Analyst team to 
forecast trades for the following financial year.

See next slide for requirements on the output of your program. 

Framework considerations
Think about common tasks that may exist in the form of a library on crates.io 
(e.g Excel file opening, DateTime processing). Make use of external libraries, do not reinvent the wheel.
Which functions should be separated into its own module file?
In your main function, tackle large tasks first to get the flow of the program right, 
zoom in on smaller sub tasks later.
Have a clear idea of variables that need to be mutated vs those that do not
Have a clear idea of variables that will be used throughout the main function, ensure 
variable scope is correct
Write documentation for each of your functions

Defining Custom Data Types
In main.rs:
mod location;

Csv Line Reader Helpers
In Cargo.toml: 		include chrono version 0.4.23 under dependencies

In transaction.rs: 		use chrono::NaiveDate; 

In location.rs:
implement on Country
define country_to_continent method which takes in a referenced self and return a Continent
match on self and return an appropriate Continent variant
implement std::str::FromStr trait on Country
define Err type as referenced static string
Define from_str method which takes in a referenced string and returns a Result of <Country, Country::Err>
match on self and return an Ok encapsulating an appropriate Country variant

Import Scopes to Read Csv
in main.rs:
use std::fs::File;
use std::io::{self, BufReader, BufRead};
mod transaction;
use transaction::Transaction;

Read Csv File
in main.rs:
    in main function
        -create file variable by passing "./transactions.csv" into the File::open function, followed by calling the unwrap method
        -create reader variable by passing file variable into the BufReader::new function
        -create mutable transactions variable of type Vec<Transaction> by calling Vec::new method
        -create mutable skipped_lines variable of no explicit type simply calling Vec::new method
        -run a for loop destructured into arbitrary variables of (idx, line) using the reader variable which calls lines method followed by enumerate method
            if  idx equals to 0, continue
            create line_str variable by using line to call the unwrap method
            create parsed_transaction variable by passing line_str into Transaction::fram_csv_line method
            match on parsed_transaction
                if matches on Ok variant, push value within Ok into transactions
                If matches on Err variant, push the tuple of (idx, value within Err, line_str) into skipped_lines
        -run a for loop by using transactions to call the iter method
            print every item in transactions
        -do the same for skipped_lines

Take home: Capstone submission must 
include below!
-Utilize HashMap to keep track of the total invested amount per continent and 
print the result out for each continent
    Hint: You would need to convert the continent to String to store as keys
-Create a function that takes in a reference slice of transactions and a reference 
of Continent, and filters rows by the Continent. Print only transactions with European companies
    Hint: You would need to utilise iterators, and filter function

Capstone Project - Evaluation Criteria
Your Rust program must:
    Exclude and report on all records that are missing values
    All asset names must be fully capiltalized
    Output data must also calculate / generate new data elements representing:
        Geographical continent in which transactions occured
        Number of days any asset was under management
    Exhibit proper use of Option<T> or handling missing data.
    Exhibit proper use of proper Rust error handing (Result<T>) techniques to handle unclean data. 
    Exhibit proper use of Vectors, Hashmaps, Enums, Structs, in processing data. 
    Exhibit proper use of Modules on code modularisation.
    Exhibit proper use of Ownership principles.
    Exhibit proper use of Match over If… Else… for specific situations
    Exhibit well written and concise Documentation. This must be web compatible and generated by Rust / Cargo tools

*/

/// Module information
pub mod location;
/// Module information
pub mod transaction;
/// Module information
pub mod utils;

use std::fs::File;
use std::io::{self, BufReader, BufRead};
use transaction::Transaction;
use location::Continent;

// use crate::utils::create_transactions_hashmap; // side quest
use std::collections::HashMap;

use crate::utils::*;


/// A Rust program to process raw data representing transactions of assets under management
/// Outputs a clean list of transaction details, that can be used or stored in an analytics database 
/// and used productively by the Data Analyst team to forecast trades for the following financial year.
/// This program takes a CSV file and outputs a clean list of transaction details
/// A valid CSV file requires headers as well as 7 fields.
/// Reader skips the first header line and parses the data, separating valid and invalid transactions.
/// Valid => Stored in variable named transaction
/// Invalid => Stored in variable named skipped_lines
/// Program also outputs total invested amount per continent
/// Additionally, filters rows by the specified Continent (ie. Europe)
/// and print only transactions with specified (ie. European) companies
fn main() {
    println!("Current dir: {:?}", std::env::current_dir().unwrap());
    
    let file: File = File::open("./transactions.csv").unwrap();
    let reader: BufReader<File> = BufReader::new(file);
    let mut transactions: Vec<Transaction> = Vec::new();
    let mut skipped_lines = Vec::new();
    
    // destructured item: (usize, &i32) => (idx, line)
    for (idx, line) in reader.lines().enumerate() {
        if idx == 0 {
            continue;
        } else {
            let line_str = line.unwrap();
            let parsed_transaction = Transaction::from_csv_line(&line_str);
            match parsed_transaction {
                Ok(value) => transactions.push(value),
                Err(error) => skipped_lines.push((idx, error, line_str)),
            }
        }
    }

    println!("Below are a list of valid transactions from the CSV file:\n");
    // Prints the successful transactions
    for item in &transactions {
        println!("{:?}\n", item);
    }
    println!("Below are a list of invalid transactions from the CSV file:\n");
    for item in &skipped_lines {
        println!("{:?}\n", item);
    }

    // Matches by the continent, accumulates the total amount for the continent and prints
    print_total_invested_amount_per_continent(&mut transactions);

    // Filters and prints rows by the Continent
    print_transaction_by_continent(&mut transactions, &Continent::Europe);
    
    // Alternative implementation that returns a HashMap of transactions in Continent
    alt_print_transaction_by_continent(&mut transactions, &Continent::Europe);

    // Ignore this block - part of side quest
    // let tx = create_transactions_hashmap(&mut transactions);
    // println!("{:?}", tx);
}

// Notes from: cargo doc --open
// Usage of `cargo doc`
// Generates documentation for the current package and all of its dependencies.
// The documentation is generated in the target/doc directory, and can be viewed in a web browser.
// However, its size can be large for git uploads.
// remote: error: File capstone_assignment/google-chrome-stable_current_amd64.deb is 112.70 MB; this exceeds GitHub's file size limit of 100.00 MB
// remote: error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lfs.github.com.